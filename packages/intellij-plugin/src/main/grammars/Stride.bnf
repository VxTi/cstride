{
  parserClass="com.stride.intellij.parser.StrideParser"

  extends="com.intellij.extapi.psi.ASTWrapperPsiElement"

  psiClassPrefix="Stride"
  psiImplClassSuffix="Impl"
  psiPackage="com.stride.intellij.psi"
  psiImplPackage="com.stride.intellij.psi.impl"

  elementTypeHolderClass="com.stride.intellij.psi.StrideTypes"
  elementTypeClass="com.stride.intellij.psi.StrideElementType"
  tokenTypeClass="com.stride.intellij.psi.StrideTokenType"

  tokens=[
    FN='fn'
    STRUCT='struct'
    CONST='const'
    LET='let'
    EXTERN='extern'
    AS='as'
    RETURN='return'
    IMPORT='import'
    FOR='for'
    WHILE='while'
    MODULE='module'
    IF='if'
    ELSE='else'
    VOID='void'
    I8='i8'
    I16='i16'
    I32='i32'
    I64='i64'
    U8='u8'
    U16='u16'
    U32='u32'
    U64='u64'
    F32='f32'
    F64='f64'
    BOOL='bool'
    CHAR='char'
    STRING='string'

    SEMICOLON=';'
    COLON=':'
    COMMA=','
    DOT='.'
    EQ='='
    PLUS_PLUS='++'
    MINUS_MINUS='--'
    PLUS='+'
    MINUS='-'
    MUL='*'
    DIV='/'
    MOD='%'
    EXCL='!'
    LT='<'
    GT='>'
    LBRACE='{'
    RBRACE='}'
    LPAREN='('
    RPAREN=')'
    LBRACKET='['
    RBRACKET=']'
    COLON_COLON='::'
    EQ_EQ='=='
    EXCL_EQ='!='
    LT_EQ='<='
    GT_EQ='>='

    COMMENT='regexp:/\*([^*]|\*+[^*/])*\*+/ | //.*'

    CHAR_LITERAL="regexp:'([^\\'\r\n]|\\[^\r\n])'"
    BOOLEAN_LITERAL='regexp:true|false'
    NUMBER_LITERAL='regexp:\d+(\.\d*)?([eE][+-]?\d+)?[fFdDLuU]*|0x[0-9a-fA-F]+'
    STRING_LITERAL="regexp:\"([^\\\"\r\n]|\\[^\r\n])*\""

    IDENTIFIER='regexp:[a-zA-Z_][a-zA-Z_0-9]*'

    OPERATOR='regexp:&&|\|\|'
  ]
}

StrideFile ::= StandaloneItem*

private StandaloneItem ::= (
    FunctionDeclaration
    | ModuleStatement
    | StructDefinition
    | VariableDeclaration
    | ExternFunctionDeclaration
    | SEMICOLON
)

// --- Declarations ---
ExternFunctionDeclaration ::= EXTERN FunctionDeclarationHeader SEMICOLON
FunctionDeclaration ::= FunctionDeclarationHeader BlockStatement
private FunctionDeclarationHeader ::= FN IDENTIFIER LPAREN [FunctionParameterList] RPAREN COLON Type
FunctionParameterList ::= FunctionParameter (COMMA FunctionParameter)* [COMMA]
FunctionParameter ::= IDENTIFIER COLON Type

StructDefinition ::= STRUCT IDENTIFIER (StructDefinitionBody | StructDefinitionAlias)
private StructDefinitionBody ::= LBRACE [StructDefinitionFields] RBRACE
private StructDefinitionAlias ::= EQ Type SEMICOLON
StructDefinitionFields ::= StructField (COMMA StructField)* [COMMA]
StructField ::= IDENTIFIER COLON Type

VariableDeclaration ::= (CONST | LET) IDENTIFIER COLON Type EQ Expression SEMICOLON

// --- Types ---
Type ::= (PrimitiveType | UserType)
// <module>::<type> or <type>
PrimitiveType ::= [(IDENTIFIER COLON_COLON)*] VOID | I8 | I16 | I32 | I64 | U8 | U16 | U32 | U64 | F32 | F64 | BOOL | CHAR | STRING
UserType ::= IDENTIFIER (COLON_COLON IDENTIFIER)*

// --- Statements ---
BlockStatement ::= LBRACE Statement* RBRACE

Statement ::= VariableDeclaration
            | AssignmentStatement
            | ReturnStatement
            | ForLoopStatement
            | WhileLoopStatement
            | IfStatement
            | ExpressionStatement
            | BlockStatement
            | SEMICOLON

AssignmentStatement ::= IDENTIFIER EQ Expression SEMICOLON
ReturnStatement ::= RETURN [Expression] SEMICOLON

ForLoopStatement ::= FOR LPAREN [ForInitializerPart] [Expression] SEMICOLON [Expression] RPAREN BlockStatement
private ForInitializerPart ::= VariableDeclaration | AssignmentStatement | ExpressionStatement

WhileLoopStatement ::= WHILE LPAREN Expression RPAREN BlockStatement
ModuleStatement ::= MODULE IDENTIFIER LBRACE StandaloneItem* RBRACE
IfStatement ::= IF LPAREN Expression RPAREN BlockStatement [ELSE (IfStatement | BlockStatement)]

ExpressionStatement ::= Expression SEMICOLON

// --- Expressions (Precedence) ---
Expression ::= CastExpression

CastExpression ::= LogicalExpression (AS Type)*

LogicalExpression ::= ComparisonExpression (LogicalOp ComparisonExpression)*

ComparisonExpression ::= AdditiveExpression (ComparisonOp AdditiveExpression)*

AdditiveExpression ::= MultiplicativeExpression (AdditiveOp MultiplicativeExpression)*

MultiplicativeExpression ::= UnaryExpression (MultiplicativeOp UnaryExpression)*

UnaryExpression ::= (LhsUnaryOp UnaryExpression) | IncrDecrExpression

IncrDecrExpression ::= (IncrDecrOp AccessExpression)
                    | (PrimaryExpression (CallSuffix | MemberAccessor | MemberIndexing)* [IncrDecrOp])


AccessExpression ::= IDENTIFIER (MemberAccessor | MemberIndexing)*

private CallSuffix ::= LPAREN [ArgumentList] RPAREN
private MemberAccessor ::= DOT IDENTIFIER
private MemberIndexing ::= LBRACKET Expression RBRACKET

PrimaryExpression ::= LiteralExpression
                     | StructInitialization
                     | ParenthesizedExpression
                     | IDENTIFIER

LiteralExpression ::= NUMBER_LITERAL | STRING_LITERAL | BOOLEAN_LITERAL | CHAR_LITERAL
StructInitialization ::= IDENTIFIER COLON_COLON LBRACE [StructInitFields] RBRACE
StructInitFields ::= StructInitField (COMMA StructInitField)* [COMMA]
StructInitField ::= IDENTIFIER COLON Expression
ArgumentList ::= Expression (COMMA Expression)*
ParenthesizedExpression ::= LPAREN Expression RPAREN

private BOOLEAN_LITERAL ::= 'true' | 'false'
private LogicalOp ::= '&&' | '||'
private ComparisonOp ::= EQ_EQ | EXCL_EQ | LT | GT | LT_EQ | GT_EQ
private AdditiveOp ::= PLUS | MINUS
private MultiplicativeOp ::= MUL | DIV | MOD
private LhsUnaryOp ::= PLUS | MINUS | EXCL
private IncrDecrOp ::= PLUS_PLUS | MINUS_MINUS