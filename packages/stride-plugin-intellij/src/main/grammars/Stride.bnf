{
  parserClass="com.stride.intellij.parser.StrideParser"

  extends="com.intellij.extapi.psi.ASTWrapperPsiElement"

  psiClassPrefix="Stride"
  psiImplClassSuffix="Impl"
  psiPackage="com.stride.intellij.psi"
  psiImplPackage="com.stride.intellij.psi.impl"

  elementTypeHolderClass="com.stride.intellij.psi.StrideTypes"
  elementTypeClass="com.stride.intellij.psi.StrideElementType"
  tokenTypeClass="com.stride.intellij.psi.StrideTokenType"

  tokens=[
    FN='fn'
    STRUCT='struct'
    CONST='const'
    LET='let'
    EXTERN='extern'
    AS='as'
    RETURN='return'
    IMPORT='import'
    FOR='for'
    WHILE='while'
    MODULE='module'
    IF='if'
    ELSE='else'
    VOID='void'
    I8='i8'
    I16='i16'
    I32='i32'
    I64='i64'
    U8='u8'
    U16='u16'
    U32='u32'
    U64='u64'
    F32='f32'
    F64='f64'
    BOOL='bool'
    CHAR='char'
    STRING='string'

    SEMICOLON=';'
    COLON=':'
    COMMA=','
    DOT='.'
    EQ='='
    PLUS_PLUS='++'
    MINUS_MINUS='--'
    PLUS_EQ='+='
    MINUS_EQ='-='
    ASTERISK_EQ='*='
    SLASH_EQ='/='
    MOD_EQ='%='
    PLUS='+'
    MINUS='-'
    ASTERISK='*'
    AMPERSAND='&'
    DIV='/'
    MOD='%'
    EXCL='!'
    LT='<'
    GT='>'
    LBRACE='{'
    RBRACE='}'
    LPAREN='('
    RPAREN=')'
    LBRACKET='['
    RBRACKET=']'
    COLON_COLON='::'
    EQ_EQ='=='
    EXCL_EQ='!='
    LT_EQ='<='
    GT_EQ='>='

    COMMENT='regexp:/\*([^*]|\*+[^*/])*\*+/ | //.*'

    CHAR_LITERAL="regexp:'([^\\'\r\n]|\\[^\r\n])'"
    BOOLEAN_LITERAL='regexp:true|false'
    NUMBER_LITERAL='regexp:\d+(\.\d*)?([eE][+-]?\d+)?[fFdDLuU]*|0x[0-9a-fA-F]+'
    STRING_LITERAL="regexp:\"([^\\\"\r\n]|\\[^\r\n])*\""

    IDENTIFIER='regexp:[a-zA-Z_$][a-zA-Z_0-9\$]*'

    OPERATOR='regexp:&&|\|\|'
  ]
}

StrideFile ::= StandaloneItem*

private StandaloneItem ::= (
    FunctionDeclaration
    | ModuleStatement
    | StructDefinition
    | VariableDeclarationStatement
    | ExternFunctionDeclaration
    | SEMICOLON
)

// --- Declarations ---
ExternFunctionDeclaration ::= EXTERN FunctionDeclarationHeader SEMICOLON
FunctionDeclaration ::= FunctionDeclarationHeader BlockStatement
private FunctionDeclarationHeader ::= FN IDENTIFIER LPAREN [FunctionParameterList] RPAREN COLON Type
FunctionParameterList ::= FunctionParameter (COMMA FunctionParameter)* [COMMA]
FunctionParameter ::= IDENTIFIER COLON Type

StructDefinition ::= STRUCT IDENTIFIER [GenericParameterList] (StructDefinitionBody | StructDefinitionAlias)
private StructDefinitionBody ::= LBRACE [StructDefinitionFields] RBRACE
private StructDefinitionAlias ::= EQ Type SEMICOLON
StructDefinitionFields ::= StructField (COMMA StructField)* [COMMA]
StructField ::= IDENTIFIER COLON Type

GenericParameterList ::= LT GenericParameter (COMMA GenericParameter)* GT
GenericParameter ::= IDENTIFIER

VariableDeclarationInferredType ::= (CONST | LET) IDENTIFIER EQ Expression
VariableDeclaration ::= (CONST | LET) IDENTIFIER COLON Type EQ Expression

VariableDeclarationStatement ::= (VariableDeclaration | VariableDeclarationInferredType) SEMICOLON

// --- Types ---
Type ::= [(ASTERISK | AMPERSAND)*] (PrimitiveType | UserType)
// <module>::<type> or <type>
PrimitiveType ::= [(IDENTIFIER COLON_COLON)*] VOID | I8 | I16 | I32 | I64 | U8 | U16 | U32 | U64 | F32 | F64 | BOOL | CHAR | STRING
UserType ::= IDENTIFIER (COLON_COLON IDENTIFIER)*

// --- Statements ---
BlockStatement ::= LBRACE Statement* RBRACE

Statement ::= VariableDeclarationStatement
            | AssignmentStatement
            | ReturnStatement
            | ForLoopStatement
            | WhileLoopStatement
            | IfStatement
            | ExpressionStatement
            | BlockStatement
            | SEMICOLON

InlineAssignment ::= IDENTIFIER (EQ | PLUS_EQ | MINUS_EQ | ASTERISK_EQ | SLASH_EQ) Expression
AssignmentStatement ::= InlineAssignment SEMICOLON
ReturnStatement ::= RETURN [Expression] SEMICOLON

ForLoopStatement ::= FOR LPAREN [ForInitializerPart] SEMICOLON [Expression] SEMICOLON [Expression] RPAREN BlockStatement
private ForInitializerPart ::= VariableDeclaration | InlineAssignment | Expression

WhileLoopStatement ::= WHILE LPAREN Expression RPAREN BlockStatement
ModuleStatement ::= MODULE IDENTIFIER LBRACE StandaloneItem* RBRACE
IfStatement ::= IF LPAREN Expression RPAREN BlockStatement [ELSE (IfStatement | BlockStatement)]

ExpressionStatement ::= Expression SEMICOLON

// --- Expressions (Precedence, lowest to highest) ---
Expression ::= CastExpression

CastExpression ::= LogicalExpression (AS Type)*

LogicalExpression ::= ComparisonExpression (LogicalOp ComparisonExpression)*

ComparisonExpression ::= AdditiveExpression (ComparisonOp AdditiveExpression)*

AdditiveExpression ::= ASTERISKtiplicativeExpression (AdditiveOp ASTERISKtiplicativeExpression)*

ASTERISKtiplicativeExpression ::= UnaryExpression (ASTERISKtiplicativeOp UnaryExpression)*

UnaryExpression ::= LhsUnaryOp UnaryExpression
                  | IncrDecrOp UnaryExpression
                  | PostfixExpression

PostfixExpression ::= PrimaryExpression PostfixSuffix*

private PostfixSuffix ::= CallSuffix
                         | MemberAccessor
                         | MemberIndexing
                         | IncrDecrOp

private CallSuffix ::= LPAREN [ArgumentList] RPAREN
private MemberAccessor ::= DOT IDENTIFIER
private MemberIndexing ::= LBRACKET Expression RBRACKET

PrimaryExpression ::= LiteralExpression
                     | StructInitialization
                     | ParenthesizedExpression
                     | IDENTIFIER

LiteralExpression ::= NUMBER_LITERAL | STRING_LITERAL | BOOLEAN_LITERAL | CHAR_LITERAL
StructInitialization ::= IDENTIFIER COLON_COLON LBRACE [StructInitFields] RBRACE
StructInitFields ::= StructInitField (COMMA StructInitField)* [COMMA]
StructInitField ::= IDENTIFIER COLON Expression
ArgumentList ::= Expression (COMMA Expression)*
ParenthesizedExpression ::= LPAREN Expression RPAREN

private BOOLEAN_LITERAL ::= 'true' | 'false'
private LogicalOp ::= '&&' | '||'
private ComparisonOp ::= EQ_EQ | EXCL_EQ | LT | GT | LT_EQ | GT_EQ
private AdditiveOp ::= PLUS | MINUS
private ASTERISKtiplicativeOp ::= ASTERISK | DIV | MOD
private LhsUnaryOp ::= PLUS | MINUS | EXCL
private IncrDecrOp ::= PLUS_PLUS | MINUS_MINUS