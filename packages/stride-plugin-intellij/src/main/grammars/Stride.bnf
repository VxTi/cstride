{
  parserClass="com.stride.intellij.parser.StrideParser"

  extends="com.intellij.extapi.psi.ASTWrapperPsiElement"

  psiClassPrefix="Stride"
  psiImplClassSuffix="Impl"
  psiPackage="com.stride.intellij.psi"
  psiImplPackage="com.stride.intellij.psi.impl"

  elementTypeHolderClass="com.stride.intellij.psi.StrideTypes"
  elementTypeClass="com.stride.intellij.psi.StrideElementType"
  tokenTypeClass="com.stride.intellij.psi.StrideTokenType"

  tokens=[
    FN='fn'
    STRUCT='struct'
    CONST='const'
    LET='let'
    EXTERN='extern'
    AS='as'
    RETURN='return'
    IMPORT='import'
    FOR='for'
    WHILE='while'
    MODULE='module'
    PACKAGE='package'
    PUB='pub'
    ASYNC='async'
    IF='if'
    ELSE='else'
    VOID='void'
    I8='i8'
    I16='i16'
    I32='i32'
    I64='i64'
    U8='u8'
    U16='u16'
    U32='u32'
    U64='u64'
    F32='f32'
    F64='f64'
    BOOL='bool'
    CHAR='char'
    STRING='string'

    SEMICOLON=';'
    COLON=':'
    COMMA=','
    DOT='.'
    EQ='='
    PLUS_PLUS='++'
    MINUS_MINUS='--'
    ARROW='->'
    PLUS_EQ='+='
    MINUS_EQ='-='
    ASTERISK_EQ='*='
    SLASH_EQ='/='
    MOD_EQ='%='
    PLUS='+'
    MINUS='-'
    ASTERISK='*'
    AMPERSAND='&'
    DIV='/'
    MOD='%'
    EXCL='!'
    LT='<'
    GT='>'
    LBRACE='{'
    RBRACE='}'
    LPAREN='('
    RPAREN=')'
    LBRACKET='['
    RBRACKET=']'
    COLON_COLON='::'
    EQ_EQ='=='
    EXCL_EQ='!='
    LT_EQ='<='
    GT_EQ='>='

    COMMENT='regexp:/\*([^*]|\*+[^*/])*\*+/ | //.*'

    CHAR_LITERAL="regexp:'([^\\'\r\n]|\\[^\r\n])'"
    BOOLEAN_LITERAL='regexp:true|false'
    NUMBER_LITERAL='regexp:\d+(\.\d*)?([eE][+-]?\d+)?[fFdDLuU]*|0x[0-9a-fA-F]+'
    STRING_LITERAL="regexp:\"([^\\\"\r\n]|\\[^\r\n])*\""

    IDENTIFIER='regexp:[a-zA-Z_\\$][a-zA-Z_0-9\\$]*'

    OPERATOR='regexp:&&|\|\|'
  ]
}

StrideFile ::= [PackageStatement] StandaloneItem*

private StandaloneItem ::= (
    FunctionDeclaration
    | ModuleStatement
    | StructDefinition
    | VariableDeclarationStatement
    | ExternFunctionDeclaration
    | SEMICOLON
)

// --- Declarations ---
ExternFunctionDeclaration ::= [AccessModifier] [ASYNC] EXTERN FunctionDeclarationHeader SEMICOLON
FunctionDeclaration ::= [AccessModifier] [ASYNC] FunctionDeclarationHeader BlockStatement
private FunctionDeclarationHeader ::= FN IDENTIFIER LPAREN [FunctionParameterList] RPAREN COLON Type
FunctionParameterList ::= FunctionParameter (COMMA FunctionParameter)* [COMMA]
FunctionParameter ::= IDENTIFIER COLON Type

StructDefinition ::= [AccessModifier] STRUCT IDENTIFIER [GenericParameterList] (StructDefinitionBody | StructDefinitionAlias)
private StructDefinitionBody ::= LBRACE [StructDefinitionFields] RBRACE
private StructDefinitionAlias ::= EQ Type SEMICOLON
StructDefinitionFields ::= StructField (SEMICOLON StructField)* [SEMICOLON]
StructField ::= IDENTIFIER COLON Type

GenericParameterList ::= LT GenericParameter (COMMA GenericParameter)* GT
GenericParameter ::= IDENTIFIER

VariableDeclarationInferredType ::= (CONST | LET) IDENTIFIER EQ Expression
VariableDeclaration ::= (CONST | LET) IDENTIFIER COLON Type EQ Expression

VariableDeclarationStatement ::= (VariableDeclaration | VariableDeclarationInferredType) SEMICOLON

// --- Types ---
Type ::= (PrimitiveType | UserType | FunctionType)
// <module>::<type> or <type>
PrimitiveType ::= (VOID | I8 | I16 | I32 | I64 | U8 | U16 | U32 | U64 | F32 | F64 | BOOL | CHAR | STRING) ArrayNotion
UserType ::= ScopedIdentifier [GenericTypeArguments] ArrayNotion*
GenericTypeArguments ::= LT Type (COMMA Type)* GT
FunctionType ::= SingularFunctionType | (LPAREN SingularFunctionType RPAREN ArrayNotion*)
SingularFunctionType ::= LPAREN [Type (COMMA Type)*] RPAREN ARROW Type

ArrayNotion ::= LBRACKET RBRACKET;

// --- Statements ---
BlockStatement ::= LBRACE Statement* RBRACE

Statement ::= VariableDeclarationStatement
            | AssignmentStatement
            | ReturnStatement
            | ForLoopStatement
            | WhileLoopStatement
            | IfStatement
            | ExpressionStatement
            | BlockStatement
            | SEMICOLON

InlineAssignment ::= IDENTIFIER (EQ | PLUS_EQ | MINUS_EQ | ASTERISK_EQ | SLASH_EQ) Expression
AssignmentStatement ::= InlineAssignment SEMICOLON
ReturnStatement ::= RETURN [Expression] SEMICOLON

ForLoopStatement ::= FOR LPAREN [ForInitializerPart] SEMICOLON [Expression] SEMICOLON [Expression] RPAREN BlockStatement
private ForInitializerPart ::= VariableDeclaration | InlineAssignment | Expression

PackageStatement ::= PACKAGE ScopedIdentifier SEMICOLON
WhileLoopStatement ::= WHILE LPAREN Expression RPAREN BlockStatement
ModuleStatement ::= MODULE ScopedIdentifier LBRACE StandaloneItem* RBRACE
IfStatement ::= IF LPAREN Expression RPAREN BlockStatement [ELSE (IfStatement | BlockStatement)]

ExpressionStatement ::= Expression SEMICOLON

// --- Expressions (Precedence, lowest to highest) ---
Expression ::= CastExpression

CastExpression ::= LogicalExpression (AS Type)*

LogicalExpression ::= ComparisonExpression (LogicalOp ComparisonExpression)*

ComparisonExpression ::= AdditiveExpression (ComparisonOp AdditiveExpression)*

AdditiveExpression ::= MultiplicativeExpression (AdditiveOp MultiplicativeExpression)*

MultiplicativeExpression ::= UnaryExpression (MultiplicativeOp UnaryExpression)*

UnaryExpression ::= LhsUnaryOp UnaryExpression
                  | IncrDecrOp UnaryExpression
                  | PostfixExpression

PostfixExpression ::= PrimaryExpression PostfixSuffix*

private PostfixSuffix ::= CallSuffix
                         | MemberAccessor
                         | MemberIndexing
                         | IncrDecrOp

private CallSuffix ::= LPAREN [ArgumentList] RPAREN
private MemberAccessor ::= DOT IDENTIFIER
private MemberIndexing ::= LBRACKET Expression RBRACKET

PrimaryExpression ::= LiteralExpression
                     | StructInitialization
                     | ParenthesizedExpression
                     | ScopedIdentifier

LiteralExpression ::= NUMBER_LITERAL | STRING_LITERAL | BOOLEAN_LITERAL | CHAR_LITERAL
StructInitialization ::= ScopedIdentifier COLON_COLON LBRACE [StructInitFields] RBRACE
StructInitFields ::= StructInitField (COMMA StructInitField)* [COMMA]
StructInitField ::= ScopedIdentifier COLON Expression
ArgumentList ::= Expression (COMMA Expression)*
ParenthesizedExpression ::= LambdaExpression | (LPAREN Expression RPAREN)

// (p: i32) -> i32 { ... }
LambdaExpression ::= LPAREN FunctionParameter* RPAREN COLON Type ARROW BlockStatement

// some::field
ScopedIdentifier ::= IDENTIFIER (COLON_COLON IDENTIFIER)*

AccessModifier ::= PUB

private BOOLEAN_LITERAL ::= 'true' | 'false'
private LogicalOp ::= '&&' | '||'
private ComparisonOp ::= EQ_EQ | EXCL_EQ | LT | GT | LT_EQ | GT_EQ
private AdditiveOp ::= PLUS | MINUS
private MultiplicativeOp ::= ASTERISK | DIV | MOD
private LhsUnaryOp ::= PLUS | MINUS | EXCL
private IncrDecrOp ::= PLUS_PLUS | MINUS_MINUS