

/**
 * In this example, we'll try to calculate an approximation of e^x using a taylor series.
 * This shows parts of the language;
 * - Function invocation
 * - External function calls
 * - The significant speed : )
 */
fn main(): void {
    mut counter: i64 = 0L

    let start: u64 = system_time_ns()

    let pow: f64 = 3.5D
    let approx: f64 = e_to_the_x(pow)

    let end: u64 = system_time_ns()
    let elapsed: u64 = end - start

    printf("Elapsed time: %llu ns; e^%.2f: %.15f\n", elapsed, pow, approx)

    exit(0)
}


// Here we try to calculate e^x by using a taylor series
// In this case, we get an accuracy of 7 digits with 20 iterations.
fn e_to_the_x(x: f64): f64 {
    mut approximation: f64 = 0.0D
    let iterations: i64 = 20L

    for (mut n: f64 = 0.0D; n < iterations; n++) {
        approximation += powl(x, n) / factorial(n)
    }

    return approximation
}

// A basic recursive factorial function
fn factorial(n: f64): f64 {
    if (n <= 1) {
        return 1.0D
    }

    // Recursive step: n * factorial of (n-1)
    return n * factorial(n - 1.0D)
}

// Used in calculating parts in the taylor series
extern fn powl(x: f64, y: f64): f64;

extern fn exit(status: i32): i32;