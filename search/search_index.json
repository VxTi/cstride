{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Stride Language","text":"<p>Stride is a statically typed, JIT-compiled language built on the LLVM compiler toolchain. It aims to combine the performance and control of low-level languages with the simplicity and safety of modern syntax.</p> <p>This project includes a complete compiler for the Stride language and a modern web-based code editor with syntax highlighting and an integrated terminal.</p>"},{"location":"#key-features","title":"Key Features","text":"<ul> <li>High Performance: Leverages LLVM for optimized machine code generation.</li> <li>Static Typing: Catch errors early with a robust type system.</li> <li>JIT Compilation: Execute code instantly without a separate compilation step.</li> <li>Modern Syntax: Clean and expressive syntax inspired by C, Rust, and TypeScript.</li> <li>Integrated Tooling: Comes with a dedicated local web editor for an immediate development experience.</li> </ul>"},{"location":"#quick-start","title":"Quick Start","text":"<ol> <li>Getting Started: Learn how to install the compiler and set up the local editor.</li> <li>Examples: Explore various code samples, from \"Hello World\" to Taylor series approximations.</li> <li>Language Reference: Dive deep into Stride's syntax, types, and features.</li> </ol>"},{"location":"#a-taste-of-stride","title":"A Taste of Stride","text":"<pre><code>fn main(): void {\n    let limit: i32 = 10\n    printf(\"Counting to %d:\\n\", limit)\n\n    for (let i: i32 = 1; i &lt;= limit; i++) {\n        if (i % 2 == 0) {\n            printf(\"%d is even\\n\", i)\n        } else {\n            printf(\"%d is odd\\n\", i)\n        }\n    }\n}</code></pre>"},{"location":"#project-status","title":"Project Status","text":"<p>Stride is currently in active development. Core language features like primitive types, functions, and control flow are stable. More advanced features like full struct support, imports, and a comprehensive standard library are currently being implemented.</p>"},{"location":"contributing/","title":"Contributing","text":"<p>Contributions are welcome!</p> <p>Please open issues or submit pull requests for improvements or bug fixes.</p>"},{"location":"examples/","title":"Examples","text":"<p>This page provides various examples of Stride programs to help you understand the language syntax and features.</p>"},{"location":"examples/#1-hello-world","title":"1. Hello World","text":"<p>The most basic program in Stride. It demonstrates how to use <code>printf</code> from the standard library.</p> <pre><code>fn main(): void {\n    printf(\"Hello, Stride!\\n\")\n}</code></pre>"},{"location":"examples/#2-fizzbuzz","title":"2. FizzBuzz","text":"<p>A classic programming challenge that demonstrates loops and conditional logic.</p> <pre><code>fn main(): void {\n    let limit: i32 = 20\n\n    for (let i: i32 = 1; i &lt;= limit; i++) {\n        if (i % 3 == 0 &amp;&amp; i % 5 == 0) {\n            printf(\"FizzBuzz\\n\")\n        } else if (i % 3 == 0) {\n            printf(\"Fizz\\n\")\n        } else if (i % 5 == 0) {\n            printf(\"Buzz\\n\")\n        } else {\n            printf(\"%d\\n\", i)\n        }\n    }\n}</code></pre>"},{"location":"examples/#3-mathematical-approximation-ex","title":"3. Mathematical Approximation (e^x)","text":"<p>This example calculates an approximation of $e^x$ using a Taylor series. It demonstrates function definition, loops, variables, and calling external functions.</p> <pre><code>extern fn powl($0: f64, $1: f64): f64;\n\n/**\n * In this example, we'll try to calculate an approximation of e^x using a taylor series.\n * This shows parts of the language;\n * - Function invocation\n * - External function calls\n * - The significant speed : )\n */\nfn main(): void {\n    const pow: f64 = 3.5D;\n\n    const start: u64 = system_time_ns();\n    const approx: f64 = e_to_the_x(pow);\n    const end: u64 = system_time_ns();\n\n    const elapsed: u64 = end - start;\n\n    printf(\"Elapsed time: %llu ns; e^%.2f: %.15f\\n\", elapsed, pow, approx);\n}\n\n\n// Here we try to calculate e^x by using a taylor series\n// In this case, we get an accuracy of 7 digits with 20 iterations.\nfn e_to_the_x(x: f64): f64 {\n    let approximation: f64 = 0.0D;\n    const iterations: i32 = 20;\n\n    for (let n: f64 = 0.0D; n &lt; iterations; n++) {\n        approximation += powl(x, n) / factorial(n);\n    }\n\n    return approximation;\n}\n\n// A basic recursive factorial function\nfn factorial(n: f64): f64 {\n    if (n &lt;= 1.0D) {\n        return 1.0D;\n    }\n\n    // Recursive step: n * factorial of (n-1)\n    return n * factorial(n - 1.0D);\n}</code></pre>"},{"location":"examples/#4-recursive-factorial-integer","title":"4. Recursive Factorial (Integer)","text":"<p>A classic example of recursion to calculate the factorial of a number using 64-bit integers.</p> <pre><code>fn main(): void {\n    let number: i64 = 10L\n    let result: i64 = factorial(number)\n    printf(\"Factorial of %lld is %lld\\n\", number, result)\n}\n\nfn factorial(n: i64): i64 {\n    if (n &lt;= 1L) {\n        return 1L\n    }\n    return n * factorial(n - 1L)\n}</code></pre>"},{"location":"examples/#5-fibonacci-sequence","title":"5. Fibonacci Sequence","text":"<p>Generating Fibonacci numbers using an iterative approach.</p> <pre><code>fn main(): void {\n    print_fibonacci(10);\n}\n\nfn print_fibonacci(n: i32): void {\n    let a = 0L;\n    let b = 1L;\n\n    printf(\"Fibonacci sequence up to %d iterations:\\n\", n);\n\n    let i: i32 = 0;\n    for (; i &lt; n; i++) {\n        printf(\"%lld \", a);\n        let temp: i64 = a;\n        a = b;\n        b = temp + b;\n    }\n    printf(\"\\n\");\n}</code></pre>"},{"location":"getting-started/","title":"Getting Started","text":"<p>Follow these instructions to build and run the Stride compiler and editor.</p>"},{"location":"getting-started/#prerequisites","title":"Prerequisites","text":"<ol> <li>CMake &gt;= 3.1</li> <li>Node.js &gt;= 24.0</li> <li>LLVM 21.1.8</li> </ol>"},{"location":"getting-started/#installation","title":"Installation","text":"<p>You can install these packages using the following commands:</p> <pre><code># MacOS \nbrew install cmake node@24 llvm@21\n</code></pre> <pre><code># Ubuntu/Debian\nsudo apt install cmake nodejs llvm-21\n</code></pre>"},{"location":"getting-started/#installation_1","title":"Installation","text":"<ol> <li>Clone the repository:    <pre><code>git clone https://github.com/VxTi/cstride.git\ncd cstride\n</code></pre>    The <code>packages/</code> directory contains the compiler and editor source code.</li> </ol>"},{"location":"getting-started/#building-the-compiler","title":"Building the Compiler","text":"<p>Run the following commands from the project root directory: <pre><code>cd packages/compiler\ncmake -S . -B cmake-build-debug\ncmake --build cmake-build-debug --target cstride\n</code></pre></p> <p>Optionally: Add the binary to your <code>$PATH</code>, if you wish to use it directly.</p>"},{"location":"getting-started/#running-the-compiler","title":"Running the Compiler","text":"<p>From the <code>packages/compiler</code> directory, you can either run it directly: <pre><code>./cmake-build-debug/cstride &lt;file_path&gt;\n</code></pre></p> <p>Or if you added it to your PATH: <pre><code>cstride &lt;file_path&gt;\n</code></pre></p>"},{"location":"getting-started/#running-the-editor","title":"Running the Editor","text":"<p>The web-based editor provides a convenient way to write Stride code with syntax highlighting and integrated terminal.</p>"},{"location":"getting-started/#prerequisites-for-editor","title":"Prerequisites for Editor","text":"<ul> <li><code>node</code> (&gt;= 24.0)</li> <li><code>pnpm</code> (Performant Node Package Manager)</li> </ul>"},{"location":"getting-started/#local-setup-and-running","title":"Local Setup and Running","text":"<p>To run the editor locally on your machine:</p> <ol> <li> <p>Navigate to the editor directory:    <pre><code>cd packages/editor\n</code></pre></p> </li> <li> <p>Install dependencies:    Using <code>pnpm</code> ensures fast and efficient dependency management.    <pre><code>pnpm install\n</code></pre></p> </li> <li> <p>Start the development server:    Launch the editor in development mode.    <pre><code>pnpm start\n</code></pre></p> </li> <li> <p>Access the Editor:    Once started, the editor will be available at <code>http://localhost:5173</code>. Open this URL in your web browser.</p> </li> </ol>"},{"location":"getting-started/#features","title":"Features","text":"<ul> <li>Real-time Syntax Highlighting: Visualizes Stride code structure.</li> <li>Integrated Terminal: Run your Stride programs directly within the editor environment.</li> <li>Local Development: Test changes to the editor itself or use it as your primary development environment for Stride.</li> </ul>"},{"location":"stdlib/","title":"Standard Library","text":"<p>The Stride standard library provides essential functions and utilities for common tasks. While still in early development, it already includes key modules for I/O, math, and system operations.</p>"},{"location":"stdlib/#available-functions","title":"Available Functions","text":"<p>Many standard library functions are currently available through the C runtime. You can use them by declaring them with the <code>extern</code> keyword.</p>"},{"location":"stdlib/#input-output-stdio","title":"Input / Output (<code>stdio</code>)","text":"<pre><code>extern fn printf(format: string, ...): i32;\nextern fn scanf(format: string, ...): i32;</code></pre>"},{"location":"stdlib/#math-mathh","title":"Math (<code>math.h</code>)","text":"<pre><code>extern fn powl(x: f64, y: f64): f64;\nextern fn sqrt(x: f64): f64;\nextern fn floor(x: f64): f64;\nextern fn ceil(x: f64): f64;</code></pre>"},{"location":"stdlib/#string-utilities-stringh","title":"String Utilities (<code>string.h</code>)","text":"<pre><code>extern fn strlen(s: string): i32;\nextern fn strcmp(s1: string, s2: string): i32;</code></pre>"},{"location":"stdlib/#system-operations","title":"System Operations","text":"<pre><code>extern fn system_time_ns(): u64;\nextern fn exit(code: i32): void;</code></pre>"},{"location":"stdlib/#planned-module-system","title":"Planned Module System","text":"<p>A full module system is currently being implemented. In the future, you will be able to import standard library modules directly:</p> <pre><code>import std::{ Math, IO };\n\nfn main(): void {\n    let x = Math::sqrt(16.0D);\n    IO::println(\"Square root is: \" + (x as string));\n}</code></pre>"},{"location":"reference/functions/","title":"Functions","text":"<p>Functions are the primary building blocks of Stride programs. They are declared using the <code>fn</code> keyword.</p>"},{"location":"reference/functions/#declaration-and-invocation","title":"Declaration and Invocation","text":"<p>A function declaration consists of the <code>fn</code> keyword, followed by the function name, a parenthesized list of parameters, and a return type after a colon.</p> <pre><code>// Function declaration\nfn add(a: i32, b: i32): i32 {\n    return a + b\n}\n\n// Function with no return value (void)\nfn greet(name: string): void {\n    printf(\"Hello, %s!\\n\", name)\n}\n\nfn main(): void {\n    // Invoking functions\n    const result: i32 = add(10, 5)\n    printf(\"10 + 5 = %d\\n\", result)\n\n    greet(\"Stride\")\n}</code></pre>"},{"location":"reference/functions/#function-parameters","title":"Function Parameters","text":"<p>Parameters are passed by value by default. Each parameter must have a name and a type.</p>"},{"location":"reference/functions/#return-values","title":"Return Values","text":"<p>Functions return values using the <code>return</code> keyword. If a function is declared with a <code>void</code> return type, it does not need a <code>return</code> statement, or it can use <code>return</code> without a value.</p>"},{"location":"reference/functions/#the-main-function","title":"The <code>main</code> Function","text":"<p>The <code>main</code> function is the entry point of every Stride program. It should have a <code>void</code> return type.</p> <pre><code>fn main(): void {\n    // Your code starts here\n}</code></pre>"},{"location":"reference/functions/#external-functions","title":"External Functions","text":"<p>You can also declare externally linked functions (e.g., from C libraries) using the <code>extern</code> keyword. These declarations do not have a body and must end with a semicolon.</p> <pre><code>// Declare printf from the C standard library\nextern fn printf(format: string, ...): i32;\n\n// Declare other external functions\nextern fn system_time_ns(): u64;\nextern fn exit(code: i32): void;\n\nfn main(): void {\n    printf(\"System time: %llu ns\\n\", system_time_ns())\n}</code></pre>"},{"location":"reference/structs/","title":"Structs","text":"<p>Structs allow you to create custom data types by grouping related values together.</p> <p>Work in Progress</p> <p>Structs are partially implemented. You can define and initialize them, but member access (e.g., <code>p.x</code>) is currently under development.</p>"},{"location":"reference/structs/#definition","title":"Definition","text":"<p>Structs are defined using the <code>struct</code> keyword followed by a name and a block of fields. Each field has a name and a type.</p> <pre><code>struct Point {\n    x: i32,\n    y: i32,\n}\n\nstruct Color {\n    r: u8,\n    g: u8,\n    b: u8,\n    a: u8,\n}</code></pre>"},{"location":"reference/structs/#initialization","title":"Initialization","text":"<p>You can initialize a struct using the <code>StructName::{ field: value, ... }</code> syntax.</p> <pre><code>fn main(): void {\n    const p: Point = Point::{ x: 10, y: 20 }\n\n    const transparent_red: Color = Color::{ \n        r: 255u8, \n        g: 0u8, \n        b: 0u8, \n        a: 128u8 \n    }\n}</code></pre>"},{"location":"reference/structs/#type-aliasing-and-nominal-typing","title":"Type Aliasing and Nominal Typing","text":"<p>Stride supports creating new types based on existing structs. These are nominal types, meaning even if they have the same structure, they are treated as distinct types by the compiler.</p> <pre><code>struct Vector2d = Point\n\nfn main(): void {\n    const p1: Point = Point::{ x: 5, y: 10 }\n    const v1: Vector2d = Vector2d::{ x: 5, y: 10 }\n\n    // The following would result in a type error:\n    // const p2: Point = v1 \n}</code></pre>"},{"location":"reference/variables/","title":"Variables and Types","text":"<p>Stride is a statically typed language.</p>"},{"location":"reference/variables/#variable-declaration","title":"Variable Declaration","text":"<p>Stride provides three keywords for variable declaration, each with different mutability rules:</p> Keyword Description <code>const</code> Declares a constant (immutable) value. <code>let</code> Declares a mutable variable. <code>mut</code> Equivalent to <code>let</code>, used for declaring mutable variables (often preferred in loop headers)."},{"location":"reference/variables/#examples","title":"Examples","text":"<pre><code>// Creating a constant variable\nconst pi: f64 = 3.14159D\n\n// Creating a mutable 32-bit integer variable\nlet x: i32 = 10\nx = 20 // OK\n\n// Using mut in a loop\nfor (mut i: i32 = 0; i &lt; 10; i++) {\n    printf(\"%d\\n\", i)\n}</code></pre>"},{"location":"reference/variables/#types","title":"Types","text":""},{"location":"reference/variables/#integer-types","title":"Integer Types","text":"<p>Stride supports several integer types: - Signed: <code>i8</code>, <code>i16</code>, <code>i32</code>, <code>i64</code> - Unsigned: <code>u8</code>, <code>u16</code>, <code>u32</code>, <code>u64</code></p>"},{"location":"reference/variables/#integer-literals","title":"Integer Literals","text":"<p>Stride supports various integer literal formats, including decimal and hexadecimal. For example, <code>0x12345</code> is a hexadecimal integer literal.</p> <p>64-bit integer literals can be suffixed with an 'L': <pre><code>let large_int: i64 = 12345678901234567890L</code></pre></p>"},{"location":"reference/variables/#floating-point-types","title":"Floating Point Types","text":"<ul> <li><code>f32</code>: Single precision</li> <li><code>f64</code>: Double precision</li> </ul> <p>Floating point literals can be suffixed with 'F' for single precision or 'D' for double precision. For example, <code>3.14F</code> is a single precision float, and <code>2.71828D</code> is a double precision float.</p>"},{"location":"reference/variables/#other-types","title":"Other Types","text":"<ul> <li><code>bool</code>: Boolean type (<code>true</code>, <code>false</code>)</li> <li><code>char</code>: Character type</li> <li><code>string</code>: String type</li> <li><code>void</code>: Void type (used for functions that don't return a value)</li> </ul>"},{"location":"reference/variables/#operators","title":"Operators","text":"<p>Stride uses traditional arithmetic and comparison operators.</p> <pre><code>let x: i32 = 10\nlet y: f64 = 3.0D\n\n// Arithmetic operators\nlet sum: f64 = (x as f64) + y\nlet difference: f64 = (x as f64) - y\nlet product: f64 = (x as f64) * y\nlet quotient: f64 = (x as f64) / y\nlet remainder: i32 = x % 3\n\n// Comparison operators\nlet is_equal: bool = (x as f64) == y\nlet is_not_equal: bool = (x as f64) != y\nlet is_less_than: bool = (x as f64) &lt; y\nlet is_greater_than: bool = (x as f64) &gt; y</code></pre>"},{"location":"reference/variables/#type-casting","title":"Type Casting","text":"<p>Stride requires explicit casting between different types using the <code>as</code> keyword.</p> <pre><code>let integer: i32 = 10\nlet floating: f64 = integer as f64</code></pre>"}]}